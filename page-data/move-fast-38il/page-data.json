{"componentChunkName":"component---src-templates-article-tsx","path":"/move-fast-38il","result":{"data":{"article":{"body_html":"<p>Here at OneHQ, we've had great success using GraphQL with Rails and TypeScript. I wanted to take the time to show off a couple techniques that we use to enable developers to move fast <del>and break things</del>:</p>\n\n<ol>\n<li><a href=\"#dynamically-create-graphql-types-in-ruby\">Dynamically create GraphQL types in Ruby</a></li>\n<li><a href=\"#commit-the-graphql-schema-to-version-control\">Commit the GraphQL schema to version control</a></li>\n<li><a href=\"#autogenerate-graphql-types-in-typescript\">Auto-generate GraphQL types in TypeScript</a></li>\n</ol>\n\n<h3>\n  <a name=\"dynamically-create-graphql-types-in-ruby\" href=\"#dynamically-create-graphql-types-in-ruby\" class=\"anchor\">\n  </a>\n  Dynamically create GraphQL types in Ruby\n</h3>\n\n<p>Our database schemas are continuously evolving, and we didn't want the overhead of having to keep our tables, models, and GraphQL types in sync. ActiveRecord gets around this by using meta-programming to dynamically analyze the database to generate methods. Why couldn't we do the same with GraphQL? </p>\n\n\n<hr>\n\n<p>We could and we did! Thus was born <a href=\"https://github.com/OneHQ/hq-graphql\">hq-graphql</a>. hq-graphql is a wrapper around <a href=\"https://graphql-ruby.org/\">graphql-ruby</a> that does all of the necessary magic to integrate with ActiveRecord. Instead of creating a bajillion types with a bazillion fields...<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">AdvisorType</span> <span class=\"o\">&lt;</span> <span class=\"o\">::</span><span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Object</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:id</span><span class=\"p\">,</span> <span class=\"no\">ID</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:created_at</span><span class=\"p\">,</span> <span class=\"no\">ISO8601DateTime</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:name</span><span class=\"p\">,</span> <span class=\"no\">String</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n  <span class=\"c1\"># &lt;bazillion fields go here (use your imagination)&gt;</span>\n  <span class=\"c1\"># &lt;bazillion fields go here (use your imagination)&gt;</span>\n  <span class=\"c1\"># &lt;bazillion fields go here (use your imagination)&gt;</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n\n\n\n<p>We can now simply reference the model to dynamically create fields.<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">AdvisorType</span> <span class=\"o\">&lt;</span> <span class=\"o\">::</span><span class=\"no\">HQ</span><span class=\"o\">::</span><span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Object</span>\n  <span class=\"n\">with_model</span> <span class=\"s2\">\"Advisor\"</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n\n\n\n\n<hr>\n\n<h3>\n  <a name=\"commit-the-graphql-schema-to-version-control\" href=\"#commit-the-graphql-schema-to-version-control\" class=\"anchor\">\n  </a>\n  Commit the GraphQL schema to version control\n</h3>\n\n<p>Once we began creating types dynamically, I feared that devs would add/remove columns from our schema without realizing that it affected GraphQL. Too much magic can be bad, especially if there isn't feedback for when something changes.</p>\n\n<p>For this reason, we dump and commit the GraphQL IDL (Interface Definition Language) to a file named schema.graphql whenever the schema changes. Checking in the schema to version control helps both the developer and code reviewer identify breaking changes before they hit production.</p>\n\n<p>To make things <em>even</em> easier, we created a test that compares the current schema with what's committed so that they can't forget to check it in! This ensures that our CI process fails whenever a dev forgets to update the schema file.</p>\n\n<h3>\n  <a name=\"autogenerate-graphql-types-in-typescript\" href=\"#autogenerate-graphql-types-in-typescript\" class=\"anchor\">\n  </a>\n  Auto-generate GraphQL types in TypeScript\n</h3>\n\n<p>Another fear of mine was that we would update the schema and forget to update the front-end!<sup>(I'm afraid of a lot)</sup> Of course you could write tests to circumvent this (and we do), but what if we could auto-generate our GraphQL types in TypeScript instead of creating them by hand? This would give us another layer of protection and allow for us to easily correct any disparities when something does change.</p>\n\n\n<hr>\n\n<p>Good news! This was the easiest of all our problems as there's already a tool out there that does this. <a href=\"https://github.com/apollographql/apollo-tooling#apollo-clientcodegen-output\">Apollo Codegen</a>.</p>\n\n<p>Point codegen to the code that uses GraphQL and run it! It pulls out any GraphQL queries and uses introspection to dynamically generate your types. If the GraphQL queries in your client don't align with your back-end, then it throws an error and lets you know what's wrong<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight shell\"><code><span class=\"nv\">$ </span>apollo client:codegen src/graphql/types/index.ts <span class=\"nt\">--endpoint</span><span class=\"o\">=</span>http://[::1]:8080/graphql <span class=\"nt\">--target</span><span class=\"o\">=</span>typescript <span class=\"nt\">--includes</span><span class=\"o\">=</span><span class=\"s1\">'src/graphql/**/**/*.{ts,tsx}'</span> <span class=\"nt\">--tagName</span><span class=\"o\">=</span>gql <span class=\"nt\">--addTypename</span> <span class=\"nt\">--outputFlat</span>\n  ‚†è Loading Apollo Project\n    Generating query files\n.../src/graphql/application/useApplications.ts: Cannot query field <span class=\"s2\">\"names\"</span> on <span class=\"nb\">type</span> <span class=\"s2\">\"Application\"</span><span class=\"nb\">.</span> Did you mean <span class=\"s2\">\"name\"</span>?\nToolError: Validation of GraphQL query document failed\n</code></pre></div>\n\n\n\n\n<hr>\n\n<h2>\n  <a name=\"conclusion\" href=\"#conclusion\" class=\"anchor\">\n  </a>\n  Conclusion\n</h2>\n\n<p>Using meta-programming to generate types has saved us countless hours at OneHQ by allowing us to focus on what really matters. <strong>But beware!!!</strong> Using meta-programming without checks and balances in your code review process could lead to a broken app.</p>\n\n","canonical_url":"https://dev.to/onehq/move-fast-38il","edited_at":"2020-05-06T23:08:18Z","title":"Move fast with GraphQL, Rails, and TypeScript"}},"pageContext":{"slug":"move-fast-38il"}}}